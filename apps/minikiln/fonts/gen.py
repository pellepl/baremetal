#!/usr/bin/env python3
import argparse
import os
import sys
from typing import Iterator

if True:  # Workaround for auto-formatter
    os.environ["PYGAME_HIDE_SUPPORT_PROMPT"] = "1"
    import pygame

FONT_SIZE = 12
OUTPUT_PATH = ""
TTF_SUFFIX = ".ttf"
AUTOGEN_COMMENT_STR = "// WARNING: Autogenerated file - do not edit!\n"
MAX_FONT_WIDTH = 0  # FONT_SIZE

# All texel data buffers are appended with four zero bytes. The target texel image
# renderer deals only in 32-bit readings to improve performance, and might overshoot up
# to 3 bytes when reading the last texel data byte, depending on alignment. On memory
# protected platforms like the simulator, this will cause a memfault when running with
# memory sanitisation.
# Each icon and each font (one texel blob per font) will thus have extra 4 bytes.

RGBA_BYTEINDEX_FROM_FILE_TO_SCRAPE = 0

code_texels_col = 0
str_externs = ""

def count_leading_zeros(values: Iterator[int]) -> int:
    res = 0
    for v in values:
        if v != 0:
            break
        res += 1
    return res


def scrape_surface(surf, bounds, key: int | str):
    """Will populate global dict graphics[key] with graphics info from given surface"""
    global graphics
    cw = 0
    ch = 0
    pixel_data = []
    rbg_divisor = 128
    try:
        if MAX_FONT_WIDTH > 0:
            cw = min(MAX_FONT_WIDTH, bounds.width)
        else:
            cw = bounds.width
        ch = bounds.height

        for x in range(cw):
            bits_in_byte = 0
            bitmask_byte = 0
            bytes_row = []

            for y in range(ch):
                rgb = surf.get_at((x, y))[RGBA_BYTEINDEX_FROM_FILE_TO_SCRAPE]
                texel = int(rgb / rbg_divisor)
                if texel > 1:
                    texel = 1
                bitmask_byte = (bitmask_byte << 1) | texel
                bits_in_byte += 1
                if bits_in_byte >= 8:
                    bytes_row.append(bitmask_byte)
                    bits_in_byte = 0
                    bitmask_byte = 0
            if bits_in_byte > 0:
                bitmask_byte = bitmask_byte << (8 - bits_in_byte)
                bytes_row.append(bitmask_byte)

            # pixel_data.insert(0, bytes_row) # images are stored upside down
            pixel_data.append(bytes_row)

        graphics[key] = {
            "dim": {"w": cw, "h": ch},
            "bytes_stride": int((ch + 7) / 8),
            "bytes": pixel_data,
            "y_begin": 0,
            "y_end": ch,
        }
    except pygame.error:
        pass
        # print("error char %d, no data" % index)


def output_byte_array_string(graphics_key: int | str, restart: bool = True):
    global graphics, code_texels_col
    if restart:
        code_texels_col = 0
    byte_count = 0
    str = ""
    for row in graphics[graphics_key]["bytes"]:
        for texel in row:
            str += f"0x{texel:02x}, "
            byte_count += 1
            code_texels_col += 6
            if code_texels_col >= 120 - 8:
                str += "\n\t"
                code_texels_col = 0

    return str, byte_count


def scrape_font_glyph(character: int):
    c = chr(character)
    try:
        surf = pygfont.render(c, True, (255, 255, 255), (0, 0, 0))
        scrape_surface(surf, surf.get_bounding_rect(), character)
    except pygame.error:
        pass
        # print("error char %d, no data" % character)


def scrape_font(
    char_ranges: list[tuple[int, int]]
):
    """Will populate global dict graphics[codepoints from ranges and hashes] with glyph info"""
    global pygfont, RGBA_BYTEINDEX_FROM_FILE_TO_SCRAPE, graphics
    if len(char_ranges) == 0:
        print("No character ranges added. See help.")
        return

    fontname = (
        "font_"
        + os.path.basename(PATH).removesuffix(TTF_SUFFIX).lower().replace("-", "_")
        + f"_{FONT_SIZE}"
    )

    glyphs = 0
    RGBA_BYTEINDEX_FROM_FILE_TO_SCRAPE = 0  # for fonts, use red channel
    pygame.font.init()
    pygfont = pygame.font.Font(PATH, FONT_SIZE)

    all_scraped_characters = []
    for r in char_ranges:
        for c in range(r[0], r[1] + 1):
            scrape_font_glyph(c)
            all_scraped_characters.append(c)
            glyphs += 1

    code_file_start = AUTOGEN_COMMENT_STR
    code_file_start += "#include <stddef.h>\n"
    code_file_start += "#include <stdint.h>\n"
    code_file_start += f'#include "{fontname}.h"\n\n'

    code_texels = "static const uint8_t texels[] = {\n\t"

    code_glyph = f"static const gfx_glyph_t glyphs[{glyphs}] = {{\n"

    bytes_offset = 0
    max_height = 0

    for c in all_scraped_characters:
        if not c in graphics:
            code_glyph += "\t{ .width = 0 },\n"
            continue

        glyph = graphics[c]
        if glyph["y_end"] > max_height:
            max_height = glyph["y_end"]
        glyph_width = glyph["dim"]["w"]
        glyph_begin = glyph["y_begin"]
        glyph_height = glyph["y_end"] - glyph["y_begin"]
        comment_char = 32 if c < 32 else c
        code_glyph += f"\t{{ .width = {glyph_width}, .raw_offset = {bytes_offset}, .y_begin = {glyph_begin}, .height = {glyph_height} }},\t// {c:d} '{comment_char:c}'\n"
        bytes_str, bytes_count = output_byte_array_string(c, restart=False)
        code_texels += bytes_str
        bytes_offset += bytes_count

    code_glyph += "};\n"
    code_texels += "\n\t0x00, 0x00, 0x00, 0x00\n"
    code_texels += "};"

    code_ranges = ""
    if len(char_ranges) > 0:
        code_ranges = (
            f"\nstatic const gfx_codepoint_range_t ranges[{len(char_ranges)}] = {{"
        )
        for r in char_ranges:
            code_ranges += f"\n\t{{ .start = {r[0]}, .end = {r[1]} }},"
        code_ranges += "\n};"


    with open(OUTPUT_PATH + f"{fontname}.c", "w") as output_file:
        print("Writing c file " + os.path.realpath(output_file.name))
        output_file.write(code_file_start)
        output_file.write(code_glyph)
        output_file.write(code_texels)
        output_file.write(code_ranges)
        output_file.write(
            f"""
const gfx_font_t {fontname} = {{
    .glyph_meta = glyphs,
    .texel_data = texels,
    .glyph_cnt = {glyphs},
    .max_height = {max_height},
    .ranges_count = {len(char_ranges)},
"""
        )
        if len(char_ranges) > 0:
            output_file.write("    .ranges = ranges,\n")
        output_file.write(
            f"""}};
// {bytes_offset+4} bytes of texels
"""
        )

    with open(OUTPUT_PATH + f"{fontname}.h", "w") as output_file:
        output_file.write(AUTOGEN_COMMENT_STR)
        output_file.write("#pragma once\n")
        output_file.write('#include "gfx.h"\n\n')
        output_file.write(f"#define {fontname.upper()}_HEIGHT {max_height}\n\n")
        output_file.write(f"extern const gfx_font_t {fontname};\n")


def intconv(x):
    return int(x, 0)


####################################################################


def main():
    global RGBA_BYTEINDEX_FROM_FILE_TO_SCRAPE, PATH, FONT_SIZE, OUTPUT_PATH
    global str_externs, graphics

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "path",
        help="""
Path to file/directory to convert.
If path points to a .ttf file, this is used for scraping graphics from characters specified in CHARS.""",
    )
    parser.add_argument(
        "-o",
        "--output-dir",
        type=str,
        default=".",
        help="Output directory. If omitted, output will be placed in current working directory.",
    )
    parser.add_argument(
        "-oh",
        "--output-header",
        type=str,
        default="externs.h",
        help="Filename for output header file, when generating images from a directory.",
    )
    parser.add_argument(
        "-s", "--font-size", type=int, default=12, help="Font size. 12 if omitted."
    )
    parser.add_argument(
        "-c",
        "--chars",
        type=str,
        nargs="*",
        default=[],
        help="Adds a character range for the font to output. Specify in form <start-character>,<end-character>, e.g -c 0x20,0x7f",
    )

    args = parser.parse_args()

    PATH = args.path
    OUTPUT_PATH = args.output_dir
    FONT_SIZE = args.font_size

    CHARACTER_RANGES = [tuple(map(intconv, x.split(","))) for x in args.chars]

    if not os.path.exists(PATH):
        print(f"Path {PATH} does not exist")
        sys.exit(1)

    os.makedirs(OUTPUT_PATH, exist_ok=True)

    print(f"OUTPUT_PATH: {OUTPUT_PATH}")
    print(f"FONT_SIZE: {FONT_SIZE}")
    print(f"CHARACTER_RANGES: {CHARACTER_RANGES}")
    graphics = dict()
    scrape_font(CHARACTER_RANGES)


if __name__ == "__main__":
    main()
